register_size 128
{
  base_types = {"uint64_t","uint64_t", "uint32_t", "uint32_t", "uint16_t", "uint16_t", "uint8_t", "uint8_t"}
  # provide one implementation for each base_type, use the same sequence as for base_types
  implementations = {
    #64 Bit int
    "switch (mask){
    case 0:   return; //store nothing
    case 1:   _mm_storeu_si128(reinterpret_cast<typename sse< v128< uint64_t > >::vector_t  *>(p_DataPtr),p_vec);
              return; //store everything
    case 2:   p_vec=_mm_shuffle_epi8(p_vec, _mm_set_epi8(7,6,5,4,3,2,1,0,15,14,13,12,11,10,9,8)); //move upper 64 bit to beginning of register and store it to memory
              _mm_storeu_si128(reinterpret_cast<typename sse< v128< uint64_t > >::vector_t  *>(p_DataPtr),p_vec);
              return;
    case 3:   _mm_storeu_si128(reinterpret_cast<typename sse< v128< uint64_t > >::vector_t  *>(p_DataPtr),p_vec); //store everything
              return;
    }
    return ;",

    "switch (mask){
    case 0:   return; //store nothing
    case 1:   _mm_storeu_si128(reinterpret_cast<typename sse< v128< uint64_t > >::vector_t  *>(p_DataPtr),p_vec);
              return; //store everything
    case 2:   p_vec=_mm_shuffle_epi8(p_vec, _mm_set_epi8(7,6,5,4,3,2,1,0,15,14,13,12,11,10,9,8)); //move upper 64 bit to beginning of register and store it to memory
              _mm_storeu_si128(reinterpret_cast<typename sse< v128< uint64_t > >::vector_t  *>(p_DataPtr),p_vec);
              return;
    case 3:   _mm_storeu_si128(reinterpret_cast<typename sse< v128< uint64_t > >::vector_t  *>(p_DataPtr),p_vec); //store everything
              return;
    }
    return ;",
    #32 Bit int
    "switch (mask){
        case 0b0000: return;
        case 0b0001: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),p_vec); return;
        case 0b0010: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_srli_si128(p_vec,4)); return;
        case 0b0011: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),p_vec); return;
        case 0b0100: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_srli_si128(p_vec,8)); return;
        case 0b0101: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_shuffle_epi8(p_vec,_mm_set_epi8(15, 14, 13, 12, 7, 6, 5, 4, 11, 10, 9, 8, 3, 2, 1, 0))); return;
        case 0b0110: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_srli_si128(p_vec,4)); return;
        case 0b0111: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),p_vec); return;
        case 0b1000: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_srli_si128(p_vec,12)); return;
        case 0b1001: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_shuffle_epi8(p_vec,_mm_set_epi8(11, 10, 9, 8, 7, 6, 5, 4, 15, 14, 13, 12, 3, 2, 1, 0))); return;
        case 0b1010: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_shuffle_epi8(p_vec,_mm_set_epi8(11, 10, 9, 8, 3, 2, 1, 0, 15, 14, 13, 12, 7, 6, 5, 4))); return;
        case 0b1011: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_shuffle_epi8(p_vec,_mm_set_epi8(11, 10, 9, 8, 15, 14, 13, 12, 7, 6, 5, 4, 3, 2, 1, 0))); return;
        case 0b1100: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_srli_si128(p_vec,8)); return;
        case 0b1101: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_shuffle_epi8(p_vec,_mm_set_epi8(7, 6, 5, 4, 15, 14, 13, 12, 11, 10, 9, 8, 3, 2, 1, 0))); return;
        case 0b1110: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_srli_si128(p_vec,4)); return;
        case 0b1111: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),p_vec); return;
     }
     return ;",

     "switch (mask){
         case 0b0000: return;
         case 0b0001: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),p_vec); return;
         case 0b0010: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_srli_si128(p_vec,4)); return;
         case 0b0011: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),p_vec); return;
         case 0b0100: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_srli_si128(p_vec,8)); return;
         case 0b0101: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_shuffle_epi8(p_vec,_mm_set_epi8(15, 14, 13, 12, 7, 6, 5, 4, 11, 10, 9, 8, 3, 2, 1, 0))); return;
         case 0b0110: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_srli_si128(p_vec,4)); return;
         case 0b0111: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),p_vec); return;
         case 0b1000: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_srli_si128(p_vec,12)); return;
         case 0b1001: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_shuffle_epi8(p_vec,_mm_set_epi8(11, 10, 9, 8, 7, 6, 5, 4, 15, 14, 13, 12, 3, 2, 1, 0))); return;
         case 0b1010: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_shuffle_epi8(p_vec,_mm_set_epi8(11, 10, 9, 8, 3, 2, 1, 0, 15, 14, 13, 12, 7, 6, 5, 4))); return;
         case 0b1011: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_shuffle_epi8(p_vec,_mm_set_epi8(11, 10, 9, 8, 15, 14, 13, 12, 7, 6, 5, 4, 3, 2, 1, 0))); return;
         case 0b1100: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_srli_si128(p_vec,8)); return;
         case 0b1101: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_shuffle_epi8(p_vec,_mm_set_epi8(7, 6, 5, 4, 15, 14, 13, 12, 11, 10, 9, 8, 3, 2, 1, 0))); return;
         case 0b1110: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),_mm_srli_si128(p_vec,4)); return;
         case 0b1111: _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),p_vec); return;
      }
      return ;",
      #16 Bit int
      "int8_t matched = 0;
       while(mask != 0){
          if((mask & 0x1) == 0x1){
             if(matched == 0){
                _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),p_vec);
                matched = 1;
             }
             p_DataPtr ++;
          }else{
             matched = 0;
          }
          mask = (mask >> 1) & 0x7FFF;
          p_vec = _mm_srli_si128(p_vec,2);
       }
       return ;",

       "int8_t matched = 0;
        while(mask != 0){
           if((mask & 0x1) == 0x1){
              if(matched == 0){
                 _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),p_vec);
                 matched = 1;
              }
              p_DataPtr ++;
           }else{
              matched = 0;
           }
           mask = (mask >> 1) & 0x7FFF;
           p_vec = _mm_srli_si128(p_vec,2);
        }
        return ;",
        #8 Bit int
        "int8_t matched = 0;
         while(mask != 0){
            if((mask & 0x1) == 0x1){
               if(matched == 0){
                  _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),p_vec);
                  matched = 1;
               }
               p_DataPtr ++;
            }else{
               matched = 0;
            }

            mask = (mask >> 1) & 0x7FFF;
            p_vec = _mm_srli_si128(p_vec,1);
         }
         return ;",

         "int8_t matched = 0;
          while(mask != 0){
             if((mask & 0x1) == 0x1){
                if(matched == 0){
                   _mm_storeu_si128(reinterpret_cast<typename sse< v128< U > >::vector_t  *>(p_DataPtr),p_vec);
                   matched = 1;
                }
                p_DataPtr ++;
             }else{
                matched = 0;
             }

             mask = (mask >> 1) & 0x7FFF;
             p_vec = _mm_srli_si128(p_vec,1);
          }
          return ;"
  }
  # number of specialized template parameters exclusing the processing style
  nr_additional_template_parameters = 2
  # additional template specializations. If there is more than 1 template argument and more than 1 base type, follow this sequence: {base type 1/argument1, base type 1/argument 2, ..., base type n/argument 1, base type n/argument 2,..., base type n/argument m}
  template_parameters = {
    "iov::UNALIGNED","64", "iov::ALIGNED","64",
    "iov::UNALIGNED","32", "iov::ALIGNED","32",
    "iov::UNALIGNED","16", "iov::ALIGNED","16",
    "iov::UNALIGNED","8", "iov::ALIGNED","8"
  }
}
