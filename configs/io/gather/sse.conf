register_size 128
{
  base_types = {"uint64_t", "uint32_t", "uint16_t", "uint8_t"}
  # provide one implementation for each base_type, use the same sequence as for base_types
  implementations = {
    "return _mm_set_epi64x(
      *reinterpret_cast<uint64_t const *>(reinterpret_cast<uint64_t const *>(p_DataPtr) + _mm_extract_epi64(p_vec,1) * 8),
      *reinterpret_cast<uint64_t const *>(reinterpret_cast<uint64_t const *>(p_DataPtr) + _mm_extract_epi64(p_vec,0) * 8)
    );",

    "return _mm_set_epi32(
               *reinterpret_cast<uint32_t const *>(reinterpret_cast<uint32_t const *>(p_DataPtr) + _mm_extract_epi32(p_vec,3) * 4),
               *reinterpret_cast<uint32_t const *>(reinterpret_cast<uint32_t const *>(p_DataPtr) + _mm_extract_epi32(p_vec,2) * 4),
               *reinterpret_cast<uint32_t const *>(reinterpret_cast<uint32_t const *>(p_DataPtr) + _mm_extract_epi32(p_vec,1) * 4),
               *reinterpret_cast<uint32_t const *>(reinterpret_cast<uint32_t const *>(p_DataPtr) + _mm_extract_epi32(p_vec,0) * 4)
     );//a bit limited",

     "return _mm_set_epi16(
               *reinterpret_cast<uint16_t const *>(reinterpret_cast<uint16_t const *>(p_DataPtr) + _mm_extract_epi16(p_vec,7) * 2),
               *reinterpret_cast<uint16_t const *>(reinterpret_cast<uint16_t const *>(p_DataPtr) + _mm_extract_epi16(p_vec,6) * 2),
               *reinterpret_cast<uint16_t const *>(reinterpret_cast<uint16_t const *>(p_DataPtr) + _mm_extract_epi16(p_vec,5) * 2),
               *reinterpret_cast<uint16_t const *>(reinterpret_cast<uint16_t const *>(p_DataPtr) + _mm_extract_epi16(p_vec,4) * 2),
               *reinterpret_cast<uint16_t const *>(reinterpret_cast<uint16_t const *>(p_DataPtr) + _mm_extract_epi16(p_vec,3) * 2),
               *reinterpret_cast<uint16_t const *>(reinterpret_cast<uint16_t const *>(p_DataPtr) + _mm_extract_epi16(p_vec,2) * 2),
               *reinterpret_cast<uint16_t const *>(reinterpret_cast<uint16_t const *>(p_DataPtr) + _mm_extract_epi16(p_vec,1) * 2),
               *reinterpret_cast<uint16_t const *>(reinterpret_cast<uint16_t const *>(p_DataPtr) + _mm_extract_epi16(p_vec,0) * 2)
     );//Possible accessible data range is 65.535/32.767",

     "return _mm_set_epi8(
               *reinterpret_cast<uint8_t const *>(reinterpret_cast<uint8_t const *>(p_DataPtr) + _mm_extract_epi8(p_vec,15) * 1),
               *reinterpret_cast<uint8_t const *>(reinterpret_cast<uint8_t const *>(p_DataPtr) + _mm_extract_epi8(p_vec,14) * 1),
               *reinterpret_cast<uint8_t const *>(reinterpret_cast<uint8_t const *>(p_DataPtr) + _mm_extract_epi8(p_vec,13) * 1),
               *reinterpret_cast<uint8_t const *>(reinterpret_cast<uint8_t const *>(p_DataPtr) + _mm_extract_epi8(p_vec,12) * 1),
               *reinterpret_cast<uint8_t const *>(reinterpret_cast<uint8_t const *>(p_DataPtr) + _mm_extract_epi8(p_vec,11) * 1),
               *reinterpret_cast<uint8_t const *>(reinterpret_cast<uint8_t const *>(p_DataPtr) + _mm_extract_epi8(p_vec,10) * 1),
               *reinterpret_cast<uint8_t const *>(reinterpret_cast<uint8_t const *>(p_DataPtr) + _mm_extract_epi8(p_vec,9) * 1),
               *reinterpret_cast<uint8_t const *>(reinterpret_cast<uint8_t const *>(p_DataPtr) + _mm_extract_epi8(p_vec,8) * 1),
               *reinterpret_cast<uint8_t const *>(reinterpret_cast<uint8_t const *>(p_DataPtr) + _mm_extract_epi8(p_vec,7) * 1),
               *reinterpret_cast<uint8_t const *>(reinterpret_cast<uint8_t const *>(p_DataPtr) + _mm_extract_epi8(p_vec,6) * 1),
               *reinterpret_cast<uint8_t const *>(reinterpret_cast<uint8_t const *>(p_DataPtr) + _mm_extract_epi8(p_vec,5) * 1),
               *reinterpret_cast<uint8_t const *>(reinterpret_cast<uint8_t const *>(p_DataPtr) + _mm_extract_epi8(p_vec,4) * 1),
               *reinterpret_cast<uint8_t const *>(reinterpret_cast<uint8_t const *>(p_DataPtr) + _mm_extract_epi8(p_vec,3) * 1),
               *reinterpret_cast<uint8_t const *>(reinterpret_cast<uint8_t const *>(p_DataPtr) + _mm_extract_epi8(p_vec,2) * 1),
               *reinterpret_cast<uint8_t const *>(reinterpret_cast<uint8_t const *>(p_DataPtr) + _mm_extract_epi8(p_vec,1) * 1),
               *reinterpret_cast<uint8_t const *>(reinterpret_cast<uint8_t const *>(p_DataPtr) + _mm_extract_epi8(p_vec,0) * 1)
     );//Possible accessible data range is 255/127"
  }
  # number of specialized template parameters exclusing the processing style
  nr_additional_template_parameters = 2
  # additional template specializations. If there is more than 1 template argument and more than 1 base type, follow this sequence: {base type 1/argument1, base type 1/argument 2, ..., base type n/argument 1, base type n/argument 2,..., base type n/argument m}
  template_parameters = {
    "iov::UNALIGNED","64",
    "iov::UNALIGNED","32",
    "iov::UNALIGNED","16",
    "iov::UNALIGNED","8"
  }
}
