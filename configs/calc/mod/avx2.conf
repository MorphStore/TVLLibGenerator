register_size 128
{
  base_types = {"uint64_t", "uint32_t"}
  # provide one implementation for each base_type, use the same sequence as for base_types
  implementations = {
    "__m128d divhelper = _mm_set1_pd(0x0010000000000000);
    __m128d intermediate =
       _mm_add_pd(
          _mm_floor_pd(
             _mm_div_pd(
                _mm_castsi128_pd(p_vec1),
                _mm_castsi128_pd(p_vec2)
             )
          ),
          divhelper
       );
    return
       _mm_sub_epi64(
          p_vec1,
          _mm_mul_epi32(
             _mm_xor_si128(
                _mm_castpd_si128(intermediate),
                _mm_castpd_si128(divhelper)
             ),
             p_vec2
          )
       );",
       "return
          _mm_sub_epi32(
             p_vec1,
             _mm_mullo_epi32( //(__m128i a, __m128i b)
                   _mm_cvtps_epi32(//(__m128 a)
                      _mm_floor_ps( //Round the packed single-precision (32-bit) floating-point elements in a down to an integer value
                         _mm_div_ps( //Divide packed single-precision (32-bit) floating-point elements (__m128 a, __m128 b)
                            _mm_castsi128_ps(p_vec1),
                            _mm_castsi128_ps(p_vec2) //Cast vector of type __m128i to type __m128
                          )
                    )
                 ),
                p_vec2
             )
          );"}
  # number of specialized template parameters exclusing the processing style
  nr_additional_template_parameters = 1
  # additional template specializations. If there is more than 1 template argument and more than 1 base type, follow this sequence: {base type 1/argument1, base type 1/argument 2, ..., base type n/argument 1, base type n/argument 2,..., base type n/argument m}
  template_parameters = {"64", "32"}
}

register_size 256
{
  base_types = {"uint64_t", "uint32_t"}
  # provide one implementation for each base_type, use the same sequence as for base_types
  implementations = {
    "__m256d divhelper = _mm256_set1_pd(0x0010000000000000);
    __m256d intermediate =
       _mm256_add_pd(
          _mm256_floor_pd(
             _mm256_div_pd(
                _mm256_castsi256_pd(p_vec1),
                _mm256_castsi256_pd(p_vec2)
             )
          ),
          divhelper
       );
    return
       _mm256_sub_epi64(
          p_vec1,
          _mm256_mul_epi32(
             _mm256_xor_si256(
                _mm256_castpd_si256(intermediate),
                _mm256_castpd_si256(divhelper)
             ),
             p_vec2
          )
       );",
       "return
          _mm256_sub_epi32(
             p_vec1,
             _mm256_mullo_epi32( //(__m256i a, __m256i b)
                   _mm256_cvtps_epi32(
                      _mm256_floor_ps( //Round the packed single-precision (32-bit) floating-point elements in a down to an integer value
                         _mm256_div_ps( //Divide packed single-precision (32-bit) floating-point elements (__m256 a, __m256 b)
                            _mm256_castsi256_ps(p_vec1),
                            _mm256_castsi256_ps(p_vec2) //Casts vector of type __m256i to type __m256
                          )
                    )
                 ),
                p_vec2
             )
          );"}
  # number of specialized template parameters exclusing the processing style
  nr_additional_template_parameters = 1
  # additional template specializations. If there is more than 1 template argument and more than 1 base type, follow this sequence: {base type 1/argument1, base type 1/argument 2, ..., base type n/argument 1, base type n/argument 2,..., base type n/argument m}
  template_parameters = {"64", "32"}
}
