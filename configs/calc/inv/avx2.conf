register_size 128
{
  base_types = {"uint64_t", "uint32_t", "uint16_t", "uint8_t"}
  # provide one implementation for each base_type, use the same sequence as for base_types
  implementations = {"return _mm_sub_epi64( _mm_set1_epi64x(0), p_vec1);", "return _mm_sub_epi32( _mm_set1_epi32(0), p_vec1);", "return _mm_sub_epi16( _mm_set1_epi16(0), p_vec1);", "return _mm_sub_epi8( _mm_set1_epi8(0), p_vec1);"}
  # number of specialized template parameters exclusing the processing style
  nr_additional_template_parameters = 1
  # additional template specializations. If there is more than 1 template argument and more than 1 base type, follow this sequence: {base type 1/argument1, base type 1/argument 2, ..., base type n/argument 1, base type n/argument 2,..., base type n/argument m}
  template_parameters = {"64", "32", "16", "8"}
}

register_size 256
{
  base_types = {"uint64_t", "uint32_t", "uint16_t", "uint8_t"}
  # provide one implementation for each base_type, use the same sequence as for base_types
  implementations = {"return _mm256_sub_epi64( _mm256_set1_epi64x(0), p_vec1);", "return _mm256_sub_epi32( _mm256_set1_epi32(0), p_vec1);", "return _mm256_sub_epi16( _mm256_set1_epi16(0), p_vec1);", "return _mm256_sub_epi8( _mm256_set1_epi8(0), p_vec1);"}
  # number of specialized template parameters exclusing the processing style
  nr_additional_template_parameters = 1
  # additional template specializations. If there is more than 1 template argument and more than 1 base type, follow this sequence: {base type 1/argument1, base type 1/argument 2, ..., base type n/argument 1, base type n/argument 2,..., base type n/argument m}
  template_parameters = {"64", "32", "16", "8"}
}
